# 第五章 装饰器和上下文管理器
掌握 Python 的装饰器和上下文管理器，有助于写出整洁的代码

## 5.1 装饰器

### 5.1.1 装饰器及其作用
* 装饰器可以应用于函数，在包装的函数（即应用装饰器的函数）之前和之后运行。装饰器有助于在函数中运行其他附加代码，常用但不限于以下场景：
    * 限制调用速率
    * 缓存值
    * 为函数的执行计时
    * 日志记录
    * 缓存异常或引发异常
    * 身份验证

### 5.1.2 理解装饰器
* 例 1：
    
    假设你有许多会返回字符串的函数
    ``` python
    def say():
        return "welcome"
    
    def hello():
        return "hello"
    
    def hi():
        return "hi"
    ```
    现在你希望将所有返回的字符串都转换为大写，一种方法是
    ``` python
    def to_uppercase(func):
        """Convert to uppercase."""
        text = func()
        if not isinstance(text, str):
            raise TypeError("Not a string type.")
        return text.upper()
    
    >>> to_uppercase(say)
    WELCOME

    >>> to_uppercase(hello):
    HELLO

    >>> to_uppercase(hi):
    HI
    ```
    但是如果你在项目的其他地方调用了这些函数，那可能修改起来比较麻烦。这时候你可以使用装饰器
    ``` python
    @to_uppercase
    def say():
        return "welcome"
    
    @to_uppercase
    def hello():
        return "hello"
    
    @to_uppercase
    def hi():
        return "hi"
    
    >>> say
    WELCOME

    >> hello
    HELLO

    >>> hi
    HI
    ```
    需要注意的是这里加入装饰器后 `say` 相当于 `to_uppercase(say())`，是一个字符串，不再是函数了。这是因为 `to_uppercase()` 直接执行了 `func`，并返回其结果


### 5.1.3 使用装饰器更改行为
* 上面例子的装饰器只是简单地调用了 `func` ，然后对其返回结果进行处理后返回。事实上，装饰器还可以返回一个 `wrapper` 函数，并在里面为 `func` 添加额外功能
    ``` python
    def compute_time(func):
        def wrapper(*args, **kwargs):
            start = time.time()
            sum_val = func(*args, **kwargs)
            end = time.time()
            duration = (end - start) * 1000
            print(f"duration: {duration} ms")
            return sum_val
        return wrapper

    @compute_time
    def add(num1, num2):
        return num1 + num2
    
    >>> c = add(100, 200)
    duration: 0.022172927856445312 ms

    >>> print(c)
    300
    ```


### 5.1.4 同时使用多个装饰器
* 装饰器的应用顺序是从下到上
    ``` python
    def to_uppercase(func):
        def wrapper(*args, **kwargs):
            print("to_uppercase")
            return func(*args, **kwargs).upper()
        return wrapper

    def add_prefix(func):
        def wrapper(*args, **kwargs):
            print("add_prefix")
            return " | ".join(["Prefix", func(*args, **kwargs)])
        return wrapper

    @to_uppercase
    @add_prefix
    def say(s):
        return s

    >>> say("hello")
    to_uppercase
    add_prefix
    'PREFIX | HELLO'")
    ```

### 5.1.5 使用带参数的装饰器
* 参见上文

### 5.1.6 考虑使用装饰器库
* 当如上使用装饰器时，被装饰的函数会丢失 `__name__`、`__doc__` 等信息
    ``` python
    >>> print(say.__name__)
    wrapper
    ```
    可以看到 `say()` 函数事实上被 `wrapper()` 替换了。为了解决这个问题，可以考虑使用 `functools.wraps`，它接受传入装饰器的函数，并添加复制的函数名、文档字符串、参数代码清单等功能
    ``` python
    from functools import wraps

    def logging(func):
        @wraps(func)
        def logs(*args, **kwargs):
            print(func.__name__ + " was called")
            return func(*args, **kwargs)
        return logs

    @logging
    def foo(x):
        """does some math"""
        return x + x * x
    
    >>> print(foo.__name__)
    foo

    >>> print(foo.__doc__)
    does some math
    ```
