# 3. 编写更好的函数和类
面向对象的五大基本设计原则：
* 单一职责原则（Single Responsibility Principle, SRP）
* 开放-封闭原则（Open-Close Principle, OCP）
* 依赖倒置原则（Dependence Inversion Principle, DIP）
* 接口隔离原则（Interface Segregation Principle, ISP）
* 里氏替换原则（Liskov Substitution Principle, LSP）

在编写函数和类时，一定要考虑函数/类的边界和结构，永远记住单一职责原则

## 3.1 函数
### 3.1.1 编写小函数
* 总是倾向于编写<u>**只完成一个任务**</u>的函数
    
    例：现有一个 `get_unique_emails(file_name)` 的函数，它首先在给定的文件上循环读取每一行，然后执行正则表达式以匹配每一行上的电子邮件地址。为了保证单一职责原则，一种可能的拆分方法为：定义生成器函数 `read_file(file_name)` 以负责接收文件名并 `yield` 每一行，而 `get_unique_emails(file_name)` 调用 `read_file` 并执行正则匹配
    ``` python
    def get_unique_emails(file_name):
        """Get all unique emails."""
        emails = set()
        for line in read_file(file_name):
            match = re.findall(r"[\w\.-]+@[\w\.-]+", line)
            for email in match:
                emails.add(email)
        return emails

    def read_file(file_name):
        """Read file and yield each line."""
        with open(file_name) as fread:
            for line in fread:
                yield line
    ```

* 建议首先编写实现功能的代码，当它确保能正常工作以后，就可以开始考虑将功能分解为多个函数

### 3.1.2 返回生成器
* 使用生成器主要考虑以下两个原因
    * 当生成器调用函数时，会立即返回迭代器而不是运行整个函数。完成后，它会自动调用内置函数 `next()`，并返回到 `yield` 关键字的下一行继续执行这个函数。它还使你的代码更易于阅读和理解
    * 在列表或其他数据结构中，Python 需要在返回之前将数据保存在内存中。如果数据过大，可能会导致内存耗尽，而生成器不存在这个问题。因此，当需要处理大量数据或无法确定数据大小时，建议优先使用生成器
    
    例：对于 3.1.1 中的例子，`get_unique_emails` 可以进一步用生成器优化成
    ``` python
    def get_unique_emails(file_name):
        """Get all unique emails."""
        for line in read_file(file_name):
            match = re.findall(r"[\w\.-]+@[\w\.-]+", line)
            for email in match:
                yield email

    def read_file(file_name):
        """Read file and yield each line."""
        with open(file_name) as fread:
            for line in fread:
                yield line

    def print_email_list():
        """Print list of emails."""
        for email in get_unique_emails("emails.txt"):
            print(email)
    ```
* 如果事先知道需要返回的数据大小，那么使用 list / tuple / set / dict 等数据结构可能会更容易

### 3.1.3 引发异常替代返回 None
* 异常是 Python 的核心特性，使用异常时需要考虑两件事
    * 当代码发生任何意外的事情时，返回 None 或者打印日志可能很危险，因为这样会隐藏 bug
    * 一个函数返回 None 或返回一些随机值的情况而不是引发异常，使得你的代码对于调用函数来说既混乱又容易出错
* 引发异常可以帮助你及早捕获 bug，而不是猜测 bug

### 3.1.4 使用默认参数和关键字参数
* 位置参数：按顺序为每个参数指定参数值
* 关键字参数（命名参数）：按参数名为参数指定参数值
    ``` python
    def add(num1, num2=0):
        return num1 + num2

    # 位置参数调用时传参需要按照函数定义中的顺序
    add(1, 2)
    >>> 3

    # num2 定义了默认值，调用时可以省略
    add(1)
    >>> 1

    # 使用关键词参数不需要严格按照函数定义的参数顺序
    add(num2=1, num1=2):
    >>> 3
    ```
    当调用函数传参很多时，为了提高可读性，最好使用关键字参数调用函数
* 关键字参数可以扩展函数的功能
    ```python
    def print_person_info(name, age, **kwargs):
        print(f"name: {name}, age: {age}, other: {kwargs}")

    print_person_info(name="A", age=10, height=187, birth_day="0101")
    ```
    ```
    >>> name: A, age: 10, other: {'height': 187, 'birth_day': '0101'}
    ```
